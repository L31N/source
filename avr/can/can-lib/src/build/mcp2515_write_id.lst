   1               		.file	"mcp2515_write_id.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               	.global	mcp2515_write_id
  11               	mcp2515_write_id:
  12               	.LFB21:
  13               		.file 1 "mcp2515_write_id.c"
   1:mcp2515_write_id.c **** // ----------------------------------------------------------------------------
   2:mcp2515_write_id.c **** /*
   3:mcp2515_write_id.c ****  * Copyright (c) 2007 Fabian Greif, Roboterclub Aachen e.V.
   4:mcp2515_write_id.c ****  *  All rights reserved.
   5:mcp2515_write_id.c ****  *
   6:mcp2515_write_id.c ****  * Redistribution and use in source and binary forms, with or without
   7:mcp2515_write_id.c ****  * modification, are permitted provided that the following conditions
   8:mcp2515_write_id.c ****  * are met:
   9:mcp2515_write_id.c ****  * 1. Redistributions of source code must retain the above copyright
  10:mcp2515_write_id.c ****  *    notice, this list of conditions and the following disclaimer.
  11:mcp2515_write_id.c ****  * 2. Redistributions in binary form must reproduce the above copyright
  12:mcp2515_write_id.c ****  *    notice, this list of conditions and the following disclaimer in the
  13:mcp2515_write_id.c ****  *    documentation and/or other materials provided with the distribution.
  14:mcp2515_write_id.c ****  *
  15:mcp2515_write_id.c ****  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
  16:mcp2515_write_id.c ****  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17:mcp2515_write_id.c ****  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  18:mcp2515_write_id.c ****  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  19:mcp2515_write_id.c ****  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  20:mcp2515_write_id.c ****  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  21:mcp2515_write_id.c ****  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  22:mcp2515_write_id.c ****  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  23:mcp2515_write_id.c ****  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  24:mcp2515_write_id.c ****  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  25:mcp2515_write_id.c ****  * SUCH DAMAGE.
  26:mcp2515_write_id.c ****  *
  27:mcp2515_write_id.c ****  * $Id: mcp2515_write_id.c 6568 2008-06-16 13:56:26Z fabian $
  28:mcp2515_write_id.c ****  */
  29:mcp2515_write_id.c **** // ----------------------------------------------------------------------------
  30:mcp2515_write_id.c **** 
  31:mcp2515_write_id.c **** #include "mcp2515_private.h"
  32:mcp2515_write_id.c **** #ifdef	SUPPORT_FOR_MCP2515__
  33:mcp2515_write_id.c **** 
  34:mcp2515_write_id.c **** // ----------------------------------------------------------------------------
  35:mcp2515_write_id.c **** #ifdef USE_SOFTWARE_SPI
  36:mcp2515_write_id.c **** 
  37:mcp2515_write_id.c **** static uint8_t usi_interface_spi_temp;
  38:mcp2515_write_id.c **** 
  39:mcp2515_write_id.c **** static void spi_start(uint8_t data) {
  40:mcp2515_write_id.c **** 	usi_interface_spi_temp = spi_putc(data);
  41:mcp2515_write_id.c **** }
  42:mcp2515_write_id.c **** 
  43:mcp2515_write_id.c **** static uint8_t spi_wait(void) {
  44:mcp2515_write_id.c **** 	return usi_interface_spi_temp;
  45:mcp2515_write_id.c **** }
  46:mcp2515_write_id.c **** 
  47:mcp2515_write_id.c **** #else
  48:mcp2515_write_id.c **** 
  49:mcp2515_write_id.c **** static void spi_start(uint8_t data) {
  50:mcp2515_write_id.c **** 	SPDR = data;
  51:mcp2515_write_id.c **** }
  52:mcp2515_write_id.c **** 
  53:mcp2515_write_id.c **** static uint8_t spi_wait(void) {
  54:mcp2515_write_id.c **** 	// warten bis der vorherige Werte geschrieben wurde
  55:mcp2515_write_id.c **** 	while(!(SPSR & (1<<SPIF)))
  56:mcp2515_write_id.c **** 		;
  57:mcp2515_write_id.c **** 	
  58:mcp2515_write_id.c **** 	return SPDR;
  59:mcp2515_write_id.c **** }
  60:mcp2515_write_id.c **** 
  61:mcp2515_write_id.c **** #endif
  62:mcp2515_write_id.c **** 
  63:mcp2515_write_id.c **** // ----------------------------------------------------------------------------
  64:mcp2515_write_id.c **** /* Schreibt eine CAN ID in die Register des MCP2515
  65:mcp2515_write_id.c ****  *
  66:mcp2515_write_id.c ****  * Die Funktion setzt eine offene Verbindung zum MCP2515 vorraus
  67:mcp2515_write_id.c ****  * und schreibt dann die CAN ID per SPI in die folgenden vier
  68:mcp2515_write_id.c ****  * Register des MCP2515.
  69:mcp2515_write_id.c ****  *
  70:mcp2515_write_id.c ****  * ACHTUNG: die Funktion wurde "optimiert", damit nicht ständig unnötige
  71:mcp2515_write_id.c ****  * 			32-Bit Operationen verwendet werden :)
  72:mcp2515_write_id.c ****  *
  73:mcp2515_write_id.c ****  * Funktionell aequivalent zu:
  74:mcp2515_write_id.c ****  *
  75:mcp2515_write_id.c ****  *	static void mcp2515_write_id(uint32_t *id, uint8_t extended)
  76:mcp2515_write_id.c ****  *	{
  77:mcp2515_write_id.c ****  *		if (extended) {
  78:mcp2515_write_id.c ****  *			spi_putc(*id >> 21);
  79:mcp2515_write_id.c ****  *			spi_putc(((*id >> 13) & 0xe0) | (1<<IDE) | ((*id >> 16) & 0x3));
  80:mcp2515_write_id.c ****  *			spi_putc(*id >> 8);
  81:mcp2515_write_id.c ****  *			spi_putc(*id);
  82:mcp2515_write_id.c ****  *		}
  83:mcp2515_write_id.c ****  *		else {
  84:mcp2515_write_id.c ****  *			spi_putc(*id >> 3);
  85:mcp2515_write_id.c ****  *			spi_putc(*id << 5);
  86:mcp2515_write_id.c ****  *			spi_putc(0);
  87:mcp2515_write_id.c ****  *			spi_putc(0);
  88:mcp2515_write_id.c ****  *		}
  89:mcp2515_write_id.c ****  *	}
  90:mcp2515_write_id.c ****  */
  91:mcp2515_write_id.c **** 
  92:mcp2515_write_id.c **** #if SUPPORT_EXTENDED_CANID
  93:mcp2515_write_id.c **** 
  94:mcp2515_write_id.c **** void mcp2515_write_id(const uint32_t *id, uint8_t extended)
  95:mcp2515_write_id.c **** {
  14               		.loc 1 95 0
  15               	.LVL0:
  16 0000 CF93      		push r28
  17               	.LCFI0:
  18 0002 DF93      		push r29
  19               	.LCFI1:
  20               	/* prologue: function */
  21               	/* frame size = 0 */
  22               	/* stack size = 2 */
  23               	.L__stack_usage = 2
  24 0004 EC01      		movw r28,r24
  96:mcp2515_write_id.c **** 	uint8_t tmp;
  97:mcp2515_write_id.c **** 	
  98:mcp2515_write_id.c **** 	if (extended) {
  25               		.loc 1 98 0
  26 0006 6623      		tst r22
  27 0008 01F0      		breq .L2
  99:mcp2515_write_id.c **** 		spi_start(*((uint16_t *) id + 1) >> 5);
  28               		.loc 1 99 0
  29 000a 8A81      		ldd r24,Y+2
  30 000c 9B81      		ldd r25,Y+3
  31               	.LVL1:
  32 000e 35E0      		ldi r19,5
  33               		1:
  34 0010 9695      		lsr r25
  35 0012 8795      		ror r24
  36 0014 3A95      		dec r19
  37 0016 01F4      		brne 1b
  38               	.LBB14:
  39               	.LBB15:
  50:mcp2515_write_id.c **** 	SPDR = data;
  40               		.loc 1 50 0
  41 0018 8EBD      		out 0x2e,r24
  42               	.LBE15:
  43               	.LBE14:
 100:mcp2515_write_id.c **** 		
 101:mcp2515_write_id.c **** 		// naechsten Werte berechnen
 102:mcp2515_write_id.c **** 		tmp  = (*((uint8_t *) id + 2) << 3) & 0xe0;
  44               		.loc 1 102 0
  45 001a 8A81      		ldd r24,Y+2
  46               	.LVL2:
  47 001c 98E0      		ldi r25,lo8(8)
  48 001e 899F      		mul r24,r25
  49 0020 9001      		movw r18,r0
  50 0022 1124      		clr __zero_reg__
  51 0024 207E      		andi r18,224
  52 0026 3327      		clr r19
 103:mcp2515_write_id.c **** 		tmp |= (1 << IDE);
  53               		.loc 1 103 0
  54 0028 2860      		ori r18,8
 104:mcp2515_write_id.c **** 		tmp |= (*((uint8_t *) id + 2)) & 0x03;
  55               		.loc 1 104 0
  56 002a 8370      		andi r24,lo8(3)
  57               	.LVL3:
  58 002c 822B      		or r24,r18
  59               	.LVL4:
  60               	.L3:
  61               	.LBB16:
  62               	.LBB17:
  55:mcp2515_write_id.c **** 	while(!(SPSR & (1<<SPIF)))
  63               		.loc 1 55 0
  64 002e 0DB4      		in __tmp_reg__,0x2d
  65 0030 07FE      		sbrs __tmp_reg__,7
  66 0032 00C0      		rjmp .L3
  58:mcp2515_write_id.c **** 	return SPDR;
  67               		.loc 1 58 0
  68 0034 9EB5      		in r25,0x2e
  69               	.LBE17:
  70               	.LBE16:
 105:mcp2515_write_id.c **** 		
 106:mcp2515_write_id.c **** 		// warten bis der vorherige Werte geschrieben wurde
 107:mcp2515_write_id.c **** 		spi_wait();
 108:mcp2515_write_id.c **** 		
 109:mcp2515_write_id.c **** 		// restliche Werte schreiben
 110:mcp2515_write_id.c **** 		spi_putc(tmp);
  71               		.loc 1 110 0
  72 0036 0E94 0000 		call spi_putc
  73               	.LVL5:
 111:mcp2515_write_id.c **** 		spi_putc(*((uint8_t *) id + 1));
  74               		.loc 1 111 0
  75 003a 8981      		ldd r24,Y+1
  76 003c 0E94 0000 		call spi_putc
  77               	.LVL6:
 112:mcp2515_write_id.c **** 		spi_putc(*((uint8_t *) id));
  78               		.loc 1 112 0
  79 0040 8881      		ld r24,Y
  80 0042 00C0      		rjmp .L7
  81               	.LVL7:
  82               	.L2:
 113:mcp2515_write_id.c **** 	}
 114:mcp2515_write_id.c **** 	else {
 115:mcp2515_write_id.c **** 		spi_start(*((uint16_t *) id) >> 3);
  83               		.loc 1 115 0
  84 0044 8881      		ld r24,Y
  85 0046 9981      		ldd r25,Y+1
  86               	.LVL8:
  87 0048 23E0      		ldi r18,3
  88               		1:
  89 004a 9695      		lsr r25
  90 004c 8795      		ror r24
  91 004e 2A95      		dec r18
  92 0050 01F4      		brne 1b
  93               	.LBB18:
  94               	.LBB19:
  50:mcp2515_write_id.c **** 	SPDR = data;
  95               		.loc 1 50 0
  96 0052 8EBD      		out 0x2e,r24
  97               	.LBE19:
  98               	.LBE18:
 116:mcp2515_write_id.c **** 		
 117:mcp2515_write_id.c **** 		// naechsten Werte berechnen
 118:mcp2515_write_id.c **** 		tmp = *((uint8_t *) id) << 5;
  99               		.loc 1 118 0
 100 0054 8881      		ld r24,Y
 101 0056 8295      		swap r24
 102 0058 880F      		lsl r24
 103 005a 807E      		andi r24,lo8(-32)
 104               	.LVL9:
 105               	.L4:
 106               	.LBB20:
 107               	.LBB21:
  55:mcp2515_write_id.c **** 	while(!(SPSR & (1<<SPIF)))
 108               		.loc 1 55 0
 109 005c 0DB4      		in __tmp_reg__,0x2d
 110 005e 07FE      		sbrs __tmp_reg__,7
 111 0060 00C0      		rjmp .L4
  58:mcp2515_write_id.c **** 	return SPDR;
 112               		.loc 1 58 0
 113 0062 9EB5      		in r25,0x2e
 114               	.LBE21:
 115               	.LBE20:
 119:mcp2515_write_id.c **** 		spi_wait();
 120:mcp2515_write_id.c **** 		
 121:mcp2515_write_id.c **** 		spi_putc(tmp);
 116               		.loc 1 121 0
 117 0064 0E94 0000 		call spi_putc
 118               	.LVL10:
 122:mcp2515_write_id.c **** 		spi_putc(0);
 119               		.loc 1 122 0
 120 0068 80E0      		ldi r24,0
 121 006a 0E94 0000 		call spi_putc
 122               	.LVL11:
 123:mcp2515_write_id.c **** 		spi_putc(0);
 123               		.loc 1 123 0
 124 006e 80E0      		ldi r24,0
 125               	.L7:
 126               	/* epilogue start */
 124:mcp2515_write_id.c **** 	}
 125:mcp2515_write_id.c **** }
 127               		.loc 1 125 0
 128 0070 DF91      		pop r29
 129 0072 CF91      		pop r28
 130               	.LVL12:
 123:mcp2515_write_id.c **** 		spi_putc(0);
 131               		.loc 1 123 0
 132 0074 0C94 0000 		jmp spi_putc
 133               	.LVL13:
 134               	.LFE21:
 174               	.Letext0:
 175               		.file 2 "/usr/lib/gcc/avr/4.7.0/../../../avr/include/stdint.h"
 176               		.file 3 "spi.h"
DEFINED SYMBOLS
                            *ABS*:00000000 mcp2515_write_id.c
     /tmp/ccYGvWv9.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccYGvWv9.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccYGvWv9.s:4      *ABS*:0000003f __SREG__
     /tmp/ccYGvWv9.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccYGvWv9.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccYGvWv9.s:11     .text:00000000 mcp2515_write_id

UNDEFINED SYMBOLS
spi_putc
