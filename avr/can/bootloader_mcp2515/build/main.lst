   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 106               	.global	boot_jump_to_application
 108               	boot_jump_to_application:
 109               		.stabd	46,0,0
   1:main.c        **** // coding: utf-8
   2:main.c        **** // ----------------------------------------------------------------------------
   3:main.c        **** /* Copyright (c) 2010, Roboterclub Aachen e.V.
   4:main.c        ****  * All rights reserved.
   5:main.c        ****  *
   6:main.c        ****  * Redistribution and use in source and binary forms, with or without
   7:main.c        ****  * modification, are permitted provided that the following conditions are met:
   8:main.c        ****  *
   9:main.c        ****  *  * Redistributions of source code must retain the above copyright
  10:main.c        ****  *    notice, this list of conditions and the following disclaimer.
  11:main.c        ****  *  * Redistributions in binary form must reproduce the above copyright
  12:main.c        ****  *    notice, this list of conditions and the following disclaimer in the
  13:main.c        ****  *    documentation and/or other materials provided with the distribution.
  14:main.c        ****  *  * Neither the name of the Roboterclub Aachen e.V. nor the
  15:main.c        ****  *    names of its contributors may be used to endorse or promote products
  16:main.c        ****  *    derived from this software without specific prior written permission.
  17:main.c        ****  *
  18:main.c        ****  * THIS SOFTWARE IS PROVIDED BY ROBOTERCLUB AACHEN E.V. ''AS IS'' AND ANY
  19:main.c        ****  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20:main.c        ****  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21:main.c        ****  * DISCLAIMED. IN NO EVENT SHALL ROBOTERCLUB AACHEN E.V. BE LIABLE FOR ANY
  22:main.c        ****  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23:main.c        ****  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24:main.c        ****  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25:main.c        ****  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26:main.c        ****  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27:main.c        ****  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28:main.c        ****  *
  29:main.c        ****  * $Id: main.c 495 2011-03-12 00:02:59Z dergraaf $
  30:main.c        ****  */
  31:main.c        **** // ----------------------------------------------------------------------------
  32:main.c        **** /**
  33:main.c        ****  * \brief	CAN Bootloader (MCP2515)
  34:main.c        ****  * 
  35:main.c        ****  * \version	$Id: main.c 495 2011-03-12 00:02:59Z dergraaf $
  36:main.c        ****  * \author	Fabian Greif <fabian.greif@rwth-aachen.de>
  37:main.c        ****  * \author	Adrian Weiler
  38:main.c        ****  */
  39:main.c        **** // ----------------------------------------------------------------------------
  40:main.c        **** 
  41:main.c        **** #include <avr/io.h>
  42:main.c        **** #include <avr/wdt.h>
  43:main.c        **** #include <avr/boot.h>
  44:main.c        **** #include <avr/eeprom.h>
  45:main.c        **** #include <avr/pgmspace.h>
  46:main.c        **** #include <avr/interrupt.h>
  47:main.c        **** #include <util/delay.h>
  48:main.c        **** 
  49:main.c        **** #include <stdint.h>
  50:main.c        **** #include <stdlib.h>
  51:main.c        **** #include <string.h>
  52:main.c        **** 
  53:main.c        **** #include "utils.h"
  54:main.c        **** 
  55:main.c        **** #include "defaults.h"
  56:main.c        **** #include "mcp2515.h"
  57:main.c        **** #include "mcp2515_defs.h"
  58:main.c        **** 
  59:main.c        **** // ----------------------------------------------------------------------------
  60:main.c        **** // global variables
  61:main.c        **** 
  62:main.c        **** static uint16_t flashpage = 0;
  63:main.c        **** static uint8_t page_buffer_pos = 0;
  64:main.c        **** static uint8_t page_buffer[SPM_PAGESIZE];
  65:main.c        **** 
  66:main.c        **** // ----------------------------------------------------------------------------
  67:main.c        **** /**
  68:main.c        ****  * \brief	starts the application program
  69:main.c        ****  */
  70:main.c        **** void
  71:main.c        **** boot_jump_to_application(void)
  72:main.c        **** {
 111               	.LM0:
 112               	.LFBB1:
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
  73:main.c        **** 	// relocate interrupt vectors
  74:main.c        **** 	uint8_t reg = IV_REG & ~((1 << IVCE) | (1 << IVSEL));
 118               	.LM1:
 119 0000 85B7      		in r24,85-32
 120 0002 8C7F      		andi r24,lo8(-4)
  75:main.c        **** 	
  76:main.c        **** 	IV_REG = reg | (1 << IVCE);
 122               	.LM2:
 123 0004 982F      		mov r25,r24
 124 0006 9160      		ori r25,lo8(1)
 125 0008 95BF      		out 85-32,r25
  77:main.c        **** 	IV_REG = reg;
 127               	.LM3:
 128 000a 85BF      		out 85-32,r24
  78:main.c        **** 	
  79:main.c        **** 	// reset SPI interface to power-up state
  80:main.c        **** 	SPCR = 0;
 130               	.LM4:
 131 000c 1CBC      		out 76-32,__zero_reg__
  81:main.c        **** 	SPSR = 0;
 133               	.LM5:
 134 000e 1DBC      		out 77-32,__zero_reg__
  82:main.c        **** 	
  83:main.c        **** #if FLASHEND > 0xffff
  84:main.c        **** 	__asm__ __volatile__(
  85:main.c        **** 			"push __zero_reg__" "\n\t"
  86:main.c        **** 			"push __zero_reg__" "\n\t"
  87:main.c        **** 			"push __zero_reg__" "\n\t");
  88:main.c        **** #else
  89:main.c        **** 	__asm__ __volatile__(
 136               	.LM6:
 137               	/* #APP */
 138               	 ;  89 "main.c" 1
 139 0010 1F92      		push __zero_reg__
 140 0012 1F92      		push __zero_reg__
 141               		
 142               	 ;  0 "" 2
 143               	/* epilogue start */
  90:main.c        **** 			"push __zero_reg__" "\n\t"
  91:main.c        **** 			"push __zero_reg__" "\n\t");
  92:main.c        **** #endif
  93:main.c        **** 	
  94:main.c        **** 	// when the functions executes the 'ret' command to return to
  95:main.c        **** 	// its origin the AVR loads the return address from the stack. Because we
  96:main.c        **** 	// pushed null it instead jumps to address null which starts the main
  97:main.c        **** 	// application.
  98:main.c        **** }
 145               	.LM7:
 146               	/* #NOAPP */
 147 0014 0895      		ret
 152               	.Lscope1:
 154               		.stabd	78,0,0
 157               	.global	boot_program_page
 159               	boot_program_page:
 160               		.stabd	46,0,0
  99:main.c        **** 
 100:main.c        **** // ----------------------------------------------------------------------------
 101:main.c        **** /**
 102:main.c        ****  * \brief	write a complete page to the flash memorey
 103:main.c        ****  * 
 104:main.c        ****  * \param	page	page which should be written
 105:main.c        ****  * \param	*buf	Pointer to the buffer with the data
 106:main.c        ****  *
 107:main.c        ****  * \see		avr-libc Documentation > Modules > Bootloader Support Utilities
 108:main.c        ****  */
 109:main.c        **** void
 110:main.c        **** boot_program_page(uint16_t page, uint8_t *buf)
 111:main.c        **** {
 162               	.LM8:
 163               	.LFBB2:
 164 0016 1F93      		push r17
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 1 */
 168               	.L__stack_usage = 1
 169 0018 DB01      		movw r26,r22
 112:main.c        **** 	uint32_t adr = page * SPM_PAGESIZE;
 171               	.LM9:
 172 001a 582F      		mov r21,r24
 173 001c 40E0      		ldi r20,lo8(0)
 113:main.c        **** 	
 114:main.c        **** 	boot_page_erase(adr);
 175               	.LM10:
 176 001e 83E0      		ldi r24,lo8(3)
 177 0020 FA01      		movw r30,r20
 178               	/* #APP */
 179               	 ;  114 "main.c" 1
 180 0022 8093 5700 		sts 87, r24
 181 0026 E895      		spm
 182               		
 183               	 ;  0 "" 2
 184               	/* #NOAPP */
 185               	.L3:
 115:main.c        **** 	boot_spm_busy_wait();	  // Wait until the memory is erased.
 187               	.LM11:
 188 0028 07B6      		in __tmp_reg__,87-32
 189 002a 00FC      		sbrc __tmp_reg__,0
 190 002c 00C0      		rjmp .L3
 192               	.LM12:
 193 002e 80E0      		ldi r24,lo8(0)
 194 0030 90E0      		ldi r25,hi8(0)
 195               	.LBB5:
 196               	.LBB6:
 116:main.c        **** 	
 117:main.c        **** 	for (uint16_t i=0; i < SPM_PAGESIZE; i+=2)
 118:main.c        **** 	{
 119:main.c        **** 		// Set up little-endian word.
 120:main.c        **** 		uint16_t w = *buf++;
 121:main.c        **** 		w += (*buf++) << 8;
 122:main.c        **** 		
 123:main.c        **** 		boot_page_fill(adr + i, w);
 198               	.LM13:
 199 0032 11E0      		ldi r17,lo8(1)
 200               	.L4:
 120:main.c        **** 		uint16_t w = *buf++;
 202               	.LM14:
 203 0034 6C91      		ld r22,X
 121:main.c        **** 		w += (*buf++) << 8;
 205               	.LM15:
 206 0036 1196      		adiw r26,1
 207 0038 3C91      		ld r19,X
 208 003a 1197      		sbiw r26,1
 209 003c 20E0      		ldi r18,lo8(0)
 210 003e F901      		movw r30,r18
 211 0040 E60F      		add r30,r22
 212 0042 F11D      		adc r31,__zero_reg__
 213 0044 BF01      		movw r22,r30
 110:main.c        **** boot_program_page(uint16_t page, uint8_t *buf)
 215               	.LM16:
 216 0046 1296      		adiw r26,2
 218               	.LM17:
 219 0048 FC01      		movw r30,r24
 220 004a E40F      		add r30,r20
 221 004c F51F      		adc r31,r21
 222               	/* #APP */
 223               	 ;  123 "main.c" 1
 224 004e 0B01      		movw  r0, r22
 225 0050 1093 5700 		sts 87, r17
 226 0054 E895      		spm
 227 0056 1124      		clr  r1
 228               		
 229               	 ;  0 "" 2
 230               	/* #NOAPP */
 231               	.LBE6:
 117:main.c        **** 	for (uint16_t i=0; i < SPM_PAGESIZE; i+=2)
 233               	.LM18:
 234 0058 0296      		adiw r24,2
 235 005a F1E0      		ldi r31,hi8(256)
 236 005c 8030      		cpi r24,lo8(256)
 237 005e 9F07      		cpc r25,r31
 238 0060 01F4      		brne .L4
 239               	.LBE5:
 124:main.c        **** 	}
 125:main.c        **** 	
 126:main.c        **** 	boot_page_write(adr);		// Store buffer in flash page.
 241               	.LM19:
 242 0062 85E0      		ldi r24,lo8(5)
 243 0064 FA01      		movw r30,r20
 244               	/* #APP */
 245               	 ;  126 "main.c" 1
 246 0066 8093 5700 		sts 87, r24
 247 006a E895      		spm
 248               		
 249               	 ;  0 "" 2
 250               	/* #NOAPP */
 251               	.L5:
 127:main.c        **** 	boot_spm_busy_wait();		// Wait until the memory is written.
 253               	.LM20:
 254 006c 07B6      		in __tmp_reg__,87-32
 255 006e 00FC      		sbrc __tmp_reg__,0
 256 0070 00C0      		rjmp .L5
 128:main.c        **** 	
 129:main.c        **** 	// Reenable RWW-section again. We need this if we want to jump back
 130:main.c        **** 	// to the application after bootloading.
 131:main.c        **** 	boot_rww_enable();
 258               	.LM21:
 259 0072 81E1      		ldi r24,lo8(17)
 260               	/* #APP */
 261               	 ;  131 "main.c" 1
 262 0074 8093 5700 		sts 87, r24
 263 0078 E895      		spm
 264               		
 265               	 ;  0 "" 2
 266               	/* epilogue start */
 132:main.c        **** }
 268               	.LM22:
 269               	/* #NOAPP */
 270 007a 1F91      		pop r17
 271 007c 0895      		ret
 276               	.Lscope2:
 278               		.stabd	78,0,0
 279               		.section	.vectors,"ax",@progbits
 281               	.global	boot
 283               	boot:
 284               		.stabd	46,0,0
 133:main.c        **** 
 134:main.c        **** // ----------------------------------------------------------------------------
 135:main.c        **** void
 136:main.c        **** boot(void) \
 137:main.c        **** 		__attribute__((naked)) \
 138:main.c        **** 		__attribute__((section(".vectors")));
 139:main.c        **** 
 140:main.c        **** void
 141:main.c        **** boot(void)
 142:main.c        **** {
 286               	.LM23:
 287               	.LFBB3:
 288               	/* prologue: naked */
 289               	/* frame size = 0 */
 290               	/* stack size = 0 */
 291               	.L__stack_usage = 0
 143:main.c        **** 	__asm__ __volatile__ ("rjmp	init" "\n\t");
 293               	.LM24:
 294               	/* #APP */
 295               	 ;  143 "main.c" 1
 296 0000 00C0      		rjmp	init
 297               		
 298               	 ;  0 "" 2
 299               	/* epilogue start */
 144:main.c        **** }
 301               	.LM25:
 302               	/* #NOAPP */
 304               	.Lscope3:
 306               		.stabd	78,0,0
 307               		.section	.init2,"ax",@progbits
 309               	.global	init
 311               	init:
 312               		.stabd	46,0,0
 145:main.c        **** 
 146:main.c        **** // ----------------------------------------------------------------------------
 147:main.c        **** void
 148:main.c        **** init(void) \
 149:main.c        **** 		__attribute__((naked)) \
 150:main.c        **** 		__attribute__((section(".init2")));
 151:main.c        **** 
 152:main.c        **** void
 153:main.c        **** init(void)
 154:main.c        **** {
 314               	.LM26:
 315               	.LFBB4:
 316               	/* prologue: naked */
 317               	/* frame size = 0 */
 318               	/* stack size = 0 */
 319               	.L__stack_usage = 0
 155:main.c        **** 	// Clear r1 (__zero_reg__) and initialize the stack
 156:main.c        **** 	__asm__ __volatile__ (
 321               	.LM27:
 322               	/* #APP */
 323               	 ;  156 "main.c" 1
 324 0000 1124      		eor  r1, r1
 325 0002 1FBE      		out  0x3f, r1
 326 0004 CFEF      		ldi  r28, 0xFF
 327 0006 D4E0      		ldi  r29, 0x04
 328 0008 DEBF      		out  0x3e, r29
 329 000a CDBF      		out  0x3d, r28
 330               		
 331               	 ;  0 "" 2
 157:main.c        **** 			"eor  r1, r1"    "\n\t"
 158:main.c        **** 			"out  0x3f, r1"  "\n\t"
 159:main.c        **** 			"ldi  r28, 0xFF" "\n\t"
 160:main.c        **** 			"ldi  r29, 0x04" "\n\t"
 161:main.c        **** 			"out  0x3e, r29" "\n\t"
 162:main.c        **** 			"out  0x3d, r28" "\n\t");
 163:main.c        **** 	
 164:main.c        **** #ifdef GPIOR0
 165:main.c        **** 	// Save MCUSR so that the main program can access if later
 166:main.c        **** 	GPIOR0 = MCUSR;
 333               	.LM28:
 334               	/* #NOAPP */
 335 000c 84B7      		in r24,84-32
 336 000e 8EBB      		out 62-32,r24
 167:main.c        **** #endif
 168:main.c        **** 	MCUSR = 0;
 338               	.LM29:
 339 0010 14BE      		out 84-32,__zero_reg__
 169:main.c        **** 	
 170:main.c        **** 	// Disable the watchdog timer
 171:main.c        **** 	// see http://www.nongnu.org/avr-libc/user-manual/group__avr__watchdog.html
 172:main.c        **** 	// 
 173:main.c        **** 	// The orignal implementation uses additional commands to disable
 174:main.c        **** 	// interrupts. As we never enable interrupts this is not needed here.
 175:main.c        **** 	__asm__ __volatile__ (  \
 341               	.LM30:
 342 0012 88E1      		ldi r24,lo8(24)
 343               	/* #APP */
 344               	 ;  175 "main.c" 1
 345 0014 8093 6000 		sts 96, r24
 346 0018 1092 6000 		sts 96, __zero_reg__
 347               		
 348               	 ;  0 "" 2
 349               	/* epilogue start */
 176:main.c        **** 			"sts %0, %1" "\n\t" \
 177:main.c        **** 			"sts %0, __zero_reg__" "\n\t" \
 178:main.c        **** 			 : /* no outputs */ \
 179:main.c        **** 			 : "M" (_SFR_MEM_ADDR(_WD_CONTROL_REG)), \
 180:main.c        **** 			   "r" ((uint8_t) ((1 << _WD_CHANGE_BIT) | (1 << WDE))) \
 181:main.c        **** 			 : "r0");
 182:main.c        **** }
 351               	.LM31:
 352               	/* #NOAPP */
 354               	.Lscope4:
 356               		.stabd	78,0,0
 357               		.section	.init9,"ax",@progbits
 359               	.global	main
 361               	main:
 362               		.stabd	46,0,0
 183:main.c        **** 
 184:main.c        **** // ----------------------------------------------------------------------------
 185:main.c        **** int
 186:main.c        **** main(void) __attribute__((naked)) \
 187:main.c        **** 		__attribute__((section(".init9")));
 188:main.c        **** 
 189:main.c        **** int
 190:main.c        **** main(void)
 191:main.c        **** {
 364               	.LM32:
 365               	.LFBB5:
 366               	/* prologue: naked */
 367               	/* frame size = 0 */
 368               	/* stack size = 0 */
 369               	.L__stack_usage = 0
 192:main.c        **** 	enum {
 193:main.c        **** 		IDLE,
 194:main.c        **** 		COLLECT_DATA,
 195:main.c        **** 		RECEIVED_PAGE
 196:main.c        **** 	} state = IDLE;
 197:main.c        **** 	uint8_t next_message_number = -1;
 198:main.c        **** 	
 199:main.c        **** 	// Do some additional initialization provided by the user
 200:main.c        **** 	BOOT_INIT;
 201:main.c        **** 	
 202:main.c        **** 	BOOT_LED_SET_OUTPUT;
 371               	.LM33:
 372 0000 219A      		sbi 36-32,1
 203:main.c        **** 	BOOT_LED_ON;
 374               	.LM34:
 375 0002 299A      		sbi 37-32,1
 204:main.c        **** 	
 205:main.c        **** 	// Start timer
 206:main.c        **** 	TCNT1 = TIMER_PRELOAD;
 377               	.LM35:
 378 0004 80EE      		ldi r24,lo8(-7200)
 379 0006 93EE      		ldi r25,hi8(-7200)
 380 0008 9093 8500 		sts 132+1,r25
 381 000c 8093 8400 		sts 132,r24
 207:main.c        **** 	TCCR1A = 0;
 383               	.LM36:
 384 0010 1092 8000 		sts 128,__zero_reg__
 208:main.c        **** 	TCCR1B = TIMER_PRESCALER;
 386               	.LM37:
 387 0014 85E0      		ldi r24,lo8(5)
 388 0016 8093 8100 		sts 129,r24
 209:main.c        **** 	
 210:main.c        **** 	// Clear overflow-flag
 211:main.c        **** 	TIMER_INTERRUPT_FLAG_REGISTER = (1 << TOV1);
 390               	.LM38:
 391 001a 81E0      		ldi r24,lo8(1)
 392 001c 86BB      		out 54-32,r24
 197:main.c        **** 	uint8_t next_message_number = -1;
 394               	.LM39:
 395 001e BB24      		clr r11
 396 0020 BA94      		dec r11
 196:main.c        **** 	} state = IDLE;
 398               	.LM40:
 399 0022 FF24      		clr r15
 400               	.LBB7:
 212:main.c        **** 	
 213:main.c        **** 	while (1)
 214:main.c        **** 	{
 215:main.c        **** 		uint8_t command;
 216:main.c        **** 		uint16_t page;
 217:main.c        **** 		static uint8_t next_message_data_counter;
 218:main.c        **** 		
 219:main.c        **** 		// wait until we receive a new message
 220:main.c        **** 		while ((command = mcp2515_get_message()) == NO_MESSAGE)
 221:main.c        **** 		{
 222:main.c        **** 			if (TIMER_INTERRUPT_FLAG_REGISTER & (1 << TOV1))
 223:main.c        **** 			{
 224:main.c        **** 				BOOT_LED_OFF;
 225:main.c        **** 
 226:main.c        **** 				// timeout => start application
 227:main.c        **** 				boot_jump_to_application();
 228:main.c        **** 			}
 229:main.c        **** 		}
 230:main.c        **** 
 231:main.c        **** 		// stop timer
 232:main.c        **** 		TCCR1B = 0;
 233:main.c        **** 		
 234:main.c        **** 		// check if the message is a request, otherwise reject it
 235:main.c        **** 		if ((command & ~COMMAND_MASK) != REQUEST) {
 236:main.c        **** 			continue;
 237:main.c        **** 		}
 238:main.c        **** 		
 239:main.c        **** 		command &= COMMAND_MASK;
 240:main.c        **** 		
 241:main.c        **** 		// check message number
 242:main.c        **** 		next_message_number++;
 243:main.c        **** 		if (message_number != next_message_number)
 244:main.c        **** 		{
 245:main.c        **** 			// wrong message number => send NACK
 246:main.c        **** 			message_number = next_message_number;
 247:main.c        **** 			next_message_number--;
 248:main.c        **** 			mcp2515_send_message(command | WRONG_NUMBER_REPSONSE, 0);
 249:main.c        **** 			continue;
 250:main.c        **** 		}
 251:main.c        **** 		
 252:main.c        **** 		BOOT_LED_TOGGLE;
 253:main.c        **** 		
 254:main.c        **** 		// process command
 255:main.c        **** 		if (command == IDENTIFY)
 256:main.c        **** 		{
 257:main.c        **** 			// version and command of the bootloader
 258:main.c        **** 			message_data[0] = (BOOTLOADER_TYPE << 4) | (BOOTLOADER_VERSION & 0x0f);
 259:main.c        **** 			message_data[1] = PAGESIZE_IDENTIFIER;
 402               	.LM41:
 403 0024 43E0      		ldi r20,lo8(3)
 404 0026 C42E      		mov r12,r20
 260:main.c        **** 			
 261:main.c        **** 			// number of writeable pages
 262:main.c        **** 			message_data[2] = HIGH_BYTE(RWW_PAGES);
 263:main.c        **** 			message_data[3] = LOW_BYTE(RWW_PAGES);
 406               	.LM42:
 407 0028 30EE      		ldi r19,lo8(-32)
 408 002a D32E      		mov r13,r19
 409 002c 00C0      		rjmp .L12
 410               	.L14:
 222:main.c        **** 			if (TIMER_INTERRUPT_FLAG_REGISTER & (1 << TOV1))
 412               	.LM43:
 413 002e B09B      		sbis 54-32,0
 414 0030 00C0      		rjmp .L23
 224:main.c        **** 				BOOT_LED_OFF;
 416               	.LM44:
 417 0032 2998      		cbi 37-32,1
 227:main.c        **** 				boot_jump_to_application();
 419               	.LM45:
 420 0034 00D0      		rcall boot_jump_to_application
 421 0036 EB2C      		mov r14,r11
 422 0038 00C0      		rjmp .L13
 423               	.L23:
 222:main.c        **** 			if (TIMER_INTERRUPT_FLAG_REGISTER & (1 << TOV1))
 425               	.LM46:
 426 003a EB2C      		mov r14,r11
 427 003c 00C0      		rjmp .L13
 428               	.L24:
 235:main.c        **** 		if ((command & ~COMMAND_MASK) != REQUEST) {
 430               	.LM47:
 431 003e EB2C      		mov r14,r11
 432               	.L13:
 235:main.c        **** 		if ((command & ~COMMAND_MASK) != REQUEST) {
 434               	.LM48:
 435 0040 BE2C      		mov r11,r14
 436               	.L12:
 220:main.c        **** 		while ((command = mcp2515_get_message()) == NO_MESSAGE)
 438               	.LM49:
 439 0042 00D0      		rcall mcp2515_get_message
 440 0044 8F33      		cpi r24,lo8(63)
 441 0046 01F0      		breq .L14
 232:main.c        **** 		TCCR1B = 0;
 443               	.LM50:
 444 0048 1092 8100 		sts 129,__zero_reg__
 235:main.c        **** 		if ((command & ~COMMAND_MASK) != REQUEST) {
 446               	.LM51:
 447 004c 982F      		mov r25,r24
 448 004e 907C      		andi r25,lo8(-64)
 449 0050 01F4      		brne .L24
 239:main.c        **** 		command &= COMMAND_MASK;
 451               	.LM52:
 452 0052 8F73      		andi r24,lo8(63)
 242:main.c        **** 		next_message_number++;
 454               	.LM53:
 455 0054 9B2D      		mov r25,r11
 456 0056 9F5F      		subi r25,lo8(-(1))
 243:main.c        **** 		if (message_number != next_message_number)
 458               	.LM54:
 459 0058 E090 0000 		lds r14,message_number
 460 005c E916      		cp r14,r25
 461 005e 01F0      		breq .L15
 246:main.c        **** 			message_number = next_message_number;
 463               	.LM55:
 464 0060 9093 0000 		sts message_number,r25
 248:main.c        **** 			mcp2515_send_message(command | WRONG_NUMBER_REPSONSE, 0);
 466               	.LM56:
 467 0064 806C      		ori r24,lo8(-64)
 468 0066 60E0      		ldi r22,lo8(0)
 469 0068 00D0      		rcall mcp2515_send_message
 247:main.c        **** 			next_message_number--;
 471               	.LM57:
 472 006a EB2C      		mov r14,r11
 249:main.c        **** 			continue;
 474               	.LM58:
 475 006c 00C0      		rjmp .L13
 476               	.L15:
 255:main.c        **** 		if (command == IDENTIFY)
 478               	.LM59:
 479 006e 8130      		cpi r24,lo8(1)
 480 0070 01F4      		brne .L16
 258:main.c        **** 			message_data[0] = (BOOTLOADER_TYPE << 4) | (BOOTLOADER_VERSION & 0x0f);
 482               	.LM60:
 483 0072 82E0      		ldi r24,lo8(2)
 484 0074 8093 0000 		sts message_data,r24
 259:main.c        **** 			message_data[1] = PAGESIZE_IDENTIFIER;
 486               	.LM61:
 487 0078 C092 0000 		sts message_data+1,r12
 262:main.c        **** 			message_data[2] = HIGH_BYTE(RWW_PAGES);
 489               	.LM62:
 490 007c 1092 0000 		sts message_data+2,__zero_reg__
 492               	.LM63:
 493 0080 D092 0000 		sts message_data+3,r13
 264:main.c        **** 			
 265:main.c        **** 			mcp2515_send_message(IDENTIFY | SUCCESSFULL_RESPONSE, 4);
 495               	.LM64:
 496 0084 81E4      		ldi r24,lo8(65)
 497 0086 64E0      		ldi r22,lo8(4)
 498 0088 00D0      		rcall mcp2515_send_message
 499 008a 00C0      		rjmp .L13
 500               	.L16:
 266:main.c        **** 		}
 267:main.c        **** 		else if (command == SET_ADDRESS)	// set the current address in the page buffer
 502               	.LM65:
 503 008c 8230      		cpi r24,lo8(2)
 504 008e 01F4      		brne .L17
 268:main.c        **** 		{
 269:main.c        **** 			page = (message_data[0] << 8) | message_data[1];
 506               	.LM66:
 507 0090 9091 0000 		lds r25,message_data
 508 0094 2091 0000 		lds r18,message_data+1
 270:main.c        **** 			
 271:main.c        **** 			if (message_data_length == 4 &&
 510               	.LM67:
 511 0098 3091 0000 		lds r19,message_data_length
 512 009c 3430      		cpi r19,lo8(4)
 513 009e 01F0      		breq .+2
 514 00a0 00C0      		rjmp .L18
 516               	.LM68:
 517 00a2 3091 0000 		lds r19,message_data+2
 518 00a6 3034      		cpi r19,lo8(64)
 519 00a8 00F0      		brlo .+2
 520 00aa 00C0      		rjmp .L18
 269:main.c        **** 			page = (message_data[0] << 8) | message_data[1];
 522               	.LM69:
 523 00ac 192F      		mov r17,r25
 524 00ae 00E0      		ldi r16,lo8(0)
 525 00b0 30E0      		ldi r19,lo8(0)
 526 00b2 202B      		or r18,r16
 527 00b4 312B      		or r19,r17
 272:main.c        **** 					message_data[2] < (SPM_PAGESIZE / 4) &&
 529               	.LM70:
 530 00b6 203E      		cpi r18,224
 531 00b8 3105      		cpc r19,__zero_reg__
 532 00ba 00F0      		brlo .+2
 533 00bc 00C0      		rjmp .L18
 273:main.c        **** 					page < RWW_PAGES)
 274:main.c        **** 			{
 275:main.c        **** 				flashpage = page;
 535               	.LM71:
 536 00be 3093 0000 		sts flashpage+1,r19
 537 00c2 2093 0000 		sts flashpage,r18
 276:main.c        **** 				page_buffer_pos = message_data[3];
 539               	.LM72:
 540 00c6 8091 0000 		lds r24,message_data+3
 541 00ca 8093 0000 		sts page_buffer_pos,r24
 277:main.c        **** 				
 278:main.c        **** 				state = COLLECT_DATA;
 279:main.c        **** 				
 280:main.c        **** 				mcp2515_send_message(SET_ADDRESS | SUCCESSFULL_RESPONSE, 4);
 543               	.LM73:
 544 00ce 82E4      		ldi r24,lo8(66)
 545 00d0 64E0      		ldi r22,lo8(4)
 546 00d2 00D0      		rcall mcp2515_send_message
 278:main.c        **** 				state = COLLECT_DATA;
 548               	.LM74:
 549 00d4 FF24      		clr r15
 550 00d6 F394      		inc r15
 551 00d8 00C0      		rjmp .L13
 552               	.L17:
 281:main.c        **** 			}
 282:main.c        **** 			else {
 283:main.c        **** 				goto error_response;
 284:main.c        **** 			}
 285:main.c        **** 		}
 286:main.c        **** 		else if (command == DATA)	// collect data
 554               	.LM75:
 555 00da 8330      		cpi r24,lo8(3)
 556 00dc 01F0      		breq .+2
 557 00de 00C0      		rjmp .L19
 287:main.c        **** 		{
 288:main.c        **** 			if (message_data_length != 4 ||
 559               	.LM76:
 560 00e0 9091 0000 		lds r25,message_data_length
 561 00e4 9430      		cpi r25,lo8(4)
 562 00e6 01F0      		breq .+2
 563 00e8 00C0      		rjmp .L25
 289:main.c        **** 					page_buffer_pos >= (SPM_PAGESIZE / 4) ||
 565               	.LM77:
 566 00ea 6091 0000 		lds r22,page_buffer_pos
 288:main.c        **** 			if (message_data_length != 4 ||
 568               	.LM78:
 569 00ee 6034      		cpi r22,lo8(64)
 570 00f0 00F0      		brlo .+2
 571 00f2 00C0      		rjmp .L26
 573               	.LM79:
 574 00f4 FF20      		tst r15
 575 00f6 01F4      		brne .+2
 576 00f8 00C0      		rjmp .L18
 290:main.c        **** 					state == IDLE) {
 291:main.c        **** 				state = IDLE;
 292:main.c        **** 				goto error_response;
 293:main.c        **** 			}
 294:main.c        **** 
 295:main.c        **** 			// check if the message starts a new block
 296:main.c        **** 			if (message_data_counter & START_OF_MESSAGE_MASK)
 578               	.LM80:
 579 00fa 9091 0000 		lds r25,message_data_counter
 580 00fe 97FF      		sbrs r25,7
 581 0100 00C0      		rjmp .L20
 297:main.c        **** 			{
 298:main.c        **** 				message_data_counter &= ~START_OF_MESSAGE_MASK;		// clear flag
 583               	.LM81:
 584 0102 9F77      		andi r25,lo8(127)
 585 0104 9093 0000 		sts message_data_counter,r25
 299:main.c        **** 				next_message_data_counter = message_data_counter;
 587               	.LM82:
 588 0108 9093 0000 		sts next_message_data_counter.1870,r25
 300:main.c        **** 				state = COLLECT_DATA;
 590               	.LM83:
 591 010c FF24      		clr r15
 592 010e F394      		inc r15
 593               	.L20:
 301:main.c        **** 			}
 302:main.c        **** 			
 303:main.c        **** 			if (message_data_counter != next_message_data_counter) {
 595               	.LM84:
 596 0110 9091 0000 		lds r25,message_data_counter
 597 0114 2091 0000 		lds r18,next_message_data_counter.1870
 598 0118 9217      		cp r25,r18
 599 011a 01F0      		breq .+2
 600 011c 00C0      		rjmp .L27
 304:main.c        **** 				state = IDLE;
 305:main.c        **** 				goto error_response;
 306:main.c        **** 			}
 307:main.c        **** 			next_message_data_counter--;
 602               	.LM85:
 603 011e 292F      		mov r18,r25
 604 0120 2150      		subi r18,lo8(-(-1))
 605 0122 2093 0000 		sts next_message_data_counter.1870,r18
 308:main.c        **** 			
 309:main.c        **** 			// copy data
 310:main.c        **** 			memcpy(page_buffer + page_buffer_pos * 4, message_data, 4);
 607               	.LM86:
 608 0126 E62F      		mov r30,r22
 609 0128 F0E0      		ldi r31,lo8(0)
 610 012a EE0F      		lsl r30
 611 012c FF1F      		rol r31
 612 012e EE0F      		lsl r30
 613 0130 FF1F      		rol r31
 614 0132 E050      		subi r30,lo8(-(page_buffer))
 615 0134 F040      		sbci r31,hi8(-(page_buffer))
 616 0136 2091 0000 		lds r18,message_data
 617 013a 3091 0000 		lds r19,message_data+1
 618 013e 4091 0000 		lds r20,message_data+2
 619 0142 5091 0000 		lds r21,message_data+3
 620 0146 2083      		st Z,r18
 621 0148 3183      		std Z+1,r19
 622 014a 4283      		std Z+2,r20
 623 014c 5383      		std Z+3,r21
 311:main.c        **** 			page_buffer_pos++;
 625               	.LM87:
 626 014e 6F5F      		subi r22,lo8(-(1))
 627 0150 6093 0000 		sts page_buffer_pos,r22
 312:main.c        **** 			
 313:main.c        **** 			if (message_data_counter == 0)
 629               	.LM88:
 630 0154 9923      		tst r25
 631 0156 01F0      		breq .+2
 632 0158 00C0      		rjmp .L13
 314:main.c        **** 			{
 315:main.c        **** 				if (page_buffer_pos == (SPM_PAGESIZE / 4))
 634               	.LM89:
 635 015a 6034      		cpi r22,lo8(64)
 636 015c 01F4      		brne .L21
 316:main.c        **** 				{
 317:main.c        **** 					message_data[0] = flashpage >> 8;
 638               	.LM90:
 639 015e C091 0000 		lds r28,flashpage
 640 0162 D091 0000 		lds r29,flashpage+1
 641 0166 5E01      		movw r10,r28
 642 0168 B092 0000 		sts message_data,r11
 318:main.c        **** 					message_data[1] = flashpage & 0xff;
 644               	.LM91:
 645 016c C093 0000 		sts message_data+1,r28
 319:main.c        **** 					
 320:main.c        **** 					if (flashpage >= RWW_PAGES) {
 647               	.LM92:
 648 0170 C03E      		cpi r28,224
 649 0172 D105      		cpc r29,__zero_reg__
 650 0174 00F0      		brlo .L22
 321:main.c        **** 						message_data_length = 2;
 652               	.LM93:
 653 0176 92E0      		ldi r25,lo8(2)
 654 0178 9093 0000 		sts message_data_length,r25
 322:main.c        **** 						goto error_response;
 656               	.LM94:
 657 017c 00C0      		rjmp .L18
 658               	.L22:
 323:main.c        **** 					}
 324:main.c        **** 					
 325:main.c        **** 					boot_program_page(flashpage, page_buffer);
 660               	.LM95:
 661 017e CE01      		movw r24,r28
 662 0180 60E0      		ldi r22,lo8(page_buffer)
 663 0182 70E0      		ldi r23,hi8(page_buffer)
 664 0184 00D0      		rcall boot_program_page
 326:main.c        **** 					page_buffer_pos = 0;
 666               	.LM96:
 667 0186 1092 0000 		sts page_buffer_pos,__zero_reg__
 327:main.c        **** 					flashpage += 1;
 669               	.LM97:
 670 018a 2196      		adiw r28,1
 671 018c D093 0000 		sts flashpage+1,r29
 672 0190 C093 0000 		sts flashpage,r28
 328:main.c        **** 					
 329:main.c        **** 					// send ACK
 330:main.c        **** 					mcp2515_send_message(DATA | SUCCESSFULL_RESPONSE, 2);
 674               	.LM98:
 675 0194 83E4      		ldi r24,lo8(67)
 676 0196 62E0      		ldi r22,lo8(2)
 677 0198 00D0      		rcall mcp2515_send_message
 678 019a 00C0      		rjmp .L13
 679               	.L21:
 331:main.c        **** 				}
 332:main.c        **** 				else {
 333:main.c        **** 					mcp2515_send_message(DATA | SUCCESSFULL_RESPONSE, 0);
 681               	.LM99:
 682 019c 83E4      		ldi r24,lo8(67)
 683 019e 60E0      		ldi r22,lo8(0)
 684 01a0 00D0      		rcall mcp2515_send_message
 685 01a2 00C0      		rjmp .L13
 686               	.L19:
 334:main.c        **** 				}
 335:main.c        **** 			}
 336:main.c        **** 		}
 337:main.c        **** 		else if (command == START_APP)	// start the flashed application program
 688               	.LM100:
 689 01a4 8430      		cpi r24,lo8(4)
 690 01a6 01F4      		brne .L18
 338:main.c        **** 		{
 339:main.c        **** 			mcp2515_send_message(START_APP | SUCCESSFULL_RESPONSE, 0);
 692               	.LM101:
 693 01a8 84E4      		ldi r24,lo8(68)
 694 01aa 60E0      		ldi r22,lo8(0)
 695 01ac 00D0      		rcall mcp2515_send_message
 696               	.LBB8:
 697               	.LBB9:
 699               	.Ltext1:
   1:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /**
  99:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    \ingroup util_delay
 100:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 101:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 102:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 103:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 104:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 105:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 106:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 107:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 108:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 109:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 110:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 111:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 112:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 113:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 115:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 116:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 117:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 118:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 119:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 120:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 121:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 122:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 123:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 124:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 125:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 126:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 127:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 128:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 129:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 130:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 131:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****  */
 132:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** void
 133:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 134:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** {
 135:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 136:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	double __tmp ; 
 137:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 138:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 139:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 140:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 141:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 142:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 143:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 144:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 145:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 146:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 147:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 148:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#else
 149:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		//round up by default
 150:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 151:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#endif
 152:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 701               	.LM102:
 702 01ae 8FEF      		 ldi r24,lo8(147455)
 703 01b0 9FE3      	    ldi r25,hi8(147455)
 704 01b2 A2E0      	    ldi r26,hlo8(147455)
 705 01b4 8150      	    1:subi r24,1
 706 01b6 9040      	    sbci r25,0
 707 01b8 A040      	    sbci r26,0
 708 01ba 01F4      	    brne 1b
 709 01bc 00C0      		rjmp .
 710 01be 0000      		nop
 711               	.LBE9:
 712               	.LBE8:
 714               	.Ltext2:
 340:main.c        **** 			
 341:main.c        **** 			// wait for the mcp2515 to send the message
 342:main.c        **** 			_delay_ms(50);
 343:main.c        **** 			
 344:main.c        **** 			// start application
 345:main.c        **** 			BOOT_LED_OFF;
 716               	.LM103:
 717 01c0 2998      		cbi 37-32,1
 346:main.c        **** 			boot_jump_to_application();
 719               	.LM104:
 720 01c2 00D0      		rcall boot_jump_to_application
 721 01c4 00C0      		rjmp .L13
 722               	.L25:
 291:main.c        **** 				state = IDLE;
 724               	.LM105:
 725 01c6 FF24      		clr r15
 726 01c8 00C0      		rjmp .L18
 727               	.L26:
 728 01ca FF24      		clr r15
 729 01cc 00C0      		rjmp .L18
 730               	.L27:
 304:main.c        **** 				state = IDLE;
 732               	.LM106:
 733 01ce FF24      		clr r15
 734               	.L18:
 347:main.c        **** 		}
 348:main.c        **** #if BOOTLOADER_TYPE > 0
 349:main.c        **** 		else if (command == GET_FUSEBITS)
 350:main.c        **** 		{
 351:main.c        **** 			message_data[0] = boot_lock_fuse_bits_get(GET_LOCK_BITS);
 352:main.c        **** 			message_data[1] = boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 353:main.c        **** 			message_data[2] = boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 354:main.c        **** 			message_data[3] = boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 355:main.c        **** 			
 356:main.c        **** 			mcp2515_send_message(GET_FUSEBITS | SUCCESSFULL_RESPONSE, 4);
 357:main.c        **** 		}
 358:main.c        **** 		else if (command == CHIP_ERASE)
 359:main.c        **** 		{
 360:main.c        **** 			// erase complete flash except the bootloader region
 361:main.c        **** 			for (uint32_t i = 0; i < RWW_PAGES; i++ )
 362:main.c        **** 			{
 363:main.c        **** 				boot_page_erase(i * SPM_PAGESIZE);
 364:main.c        **** 				boot_spm_busy_wait();
 365:main.c        **** 			}
 366:main.c        **** 			boot_rww_enable();
 367:main.c        **** 
 368:main.c        **** 			mcp2515_send_message(CHIP_ERASE | SUCCESSFULL_RESPONSE, 0);
 369:main.c        **** 		}
 370:main.c        **** /*		// der folgende Teil muss noch überarbeitet werden!!!
 371:main.c        **** 		else if (command == READ_EEPROM)
 372:main.c        **** 		{
 373:main.c        **** 			// Lese 1..6 Byte aus dem EEprom
 374:main.c        **** 			if (message_length == 5 && message_data[4] > 0 && message_data[4] <= 6)
 375:main.c        **** 			{
 376:main.c        **** 				uint16_t ee_ptr = (message_data[2] << 8) | message_data[3];
 377:main.c        **** 				
 378:main.c        **** 				if (ee_ptr <= E2END) {
 379:main.c        **** 					message_length = message_data[4] + 2;
 380:main.c        **** 					eeprom_read_block(message_data + 2, (void *) ee_ptr, message_data[4]);
 381:main.c        **** 					break;
 382:main.c        **** 				}
 383:main.c        **** 			}
 384:main.c        **** 			response = NACK;
 385:main.c        **** 		}
 386:main.c        **** 		else if (command == WRITE_EEPROM)
 387:main.c        **** 		{
 388:main.c        **** 			// schreibe 1..4 Byte ins EEprom
 389:main.c        **** 			if (message_length > 4) {
 390:main.c        **** 				uint16_t ee_ptr = (message_data[2] << 8) | message_data[3];
 391:main.c        **** 				
 392:main.c        **** 				if (ee_ptr <= E2END) {
 393:main.c        **** 					eeprom_write_block(message_data + 4,(void *) ee_ptr, message_length - 4);
 394:main.c        **** 					response = ACK;
 395:main.c        **** 					break;
 396:main.c        **** 				}
 397:main.c        **** 			}
 398:main.c        **** 			response = NACK;
 399:main.c        **** 		}
 400:main.c        **** 		else if (command == READ_FLASH)
 401:main.c        **** 		{
 402:main.c        **** 			// Lese 1..65556 Byte aus dem Flash. Bei mehr als 6 Zeichen
 403:main.c        **** 			// wird das Ergebniss auf mehrere Nachrichten verteilt.
 404:main.c        **** 			if (message_length == 6)
 405:main.c        **** 			{
 406:main.c        **** 				uint16_t flash_ptr = (message_data[2] << 8) | message_data[3];
 407:main.c        **** 				
 408:main.c        **** 				if (flash_ptr <= FLASHEND)
 409:main.c        **** 				{
 410:main.c        **** 					uint16_t number = (message_data[4] << 8) | message_data[5];
 411:main.c        **** 					
 412:main.c        **** 					// Anzahl der zu senden Nachrichten bestimmen
 413:main.c        **** 					div_t r = div(number, 6);
 414:main.c        **** 					number = r.quot;
 415:main.c        **** 					if (r.rem > 0)
 416:main.c        **** 						number += 1;
 417:main.c        **** 					
 418:main.c        **** 					uint16_t counter = 0;
 419:main.c        **** 					for (uint16_t i=0;i<number;i++)
 420:main.c        **** 					{
 421:main.c        **** 						if (i == r.quot)
 422:main.c        **** 							// das letze Paket ist eventl. kuerzer
 423:main.c        **** 							message_length = r.rem;
 424:main.c        **** 						else
 425:main.c        **** 							message_length = 6;
 426:main.c        **** 						
 427:main.c        **** 						// FIXME
 428:main.c        **** 						//memcpy_P( message_data + 2, (PGM_VOID_P) flash_ptr, message_length );
 429:main.c        **** 						flash_ptr += message_length;
 430:main.c        **** 						
 431:main.c        **** 						message_data[1] = counter;
 432:main.c        **** 						counter = (counter + 1) & 0x3f;
 433:main.c        **** 						
 434:main.c        **** 						// Nachricht verschicken
 435:main.c        **** 						mcp2515_send_message(0);
 436:main.c        **** 					}
 437:main.c        **** 					
 438:main.c        **** 					response = ACK;
 439:main.c        **** 					break;
 440:main.c        **** 				}
 441:main.c        **** 			}
 442:main.c        **** 			response = NACK;
 443:main.c        **** 		}*/
 444:main.c        **** #endif
 445:main.c        **** 		else
 446:main.c        **** 		{
 447:main.c        **** error_response:
 448:main.c        **** 			mcp2515_send_message( command | ERROR_RESPONSE, message_data_length );
 736               	.LM107:
 737 01d0 8068      		ori r24,lo8(-128)
 738 01d2 6091 0000 		lds r22,message_data_length
 739 01d6 00D0      		rcall mcp2515_send_message
 740 01d8 00C0      		rjmp .L13
 741               	.LBE7:
 750               	.Lscope5:
 752               		.stabd	78,0,0
 753               		.lcomm flashpage,2
 754               		.lcomm page_buffer_pos,1
 755               		.lcomm page_buffer,256
 756               		.lcomm next_message_data_counter.1870,1
 760               		.text
 762               	.Letext0:
 763               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/cc2L9P4q.s:2      *ABS*:0000003f __SREG__
     /tmp/cc2L9P4q.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc2L9P4q.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc2L9P4q.s:5      *ABS*:00000034 __CCP__
     /tmp/cc2L9P4q.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc2L9P4q.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc2L9P4q.s:108    .text:00000000 boot_jump_to_application
     /tmp/cc2L9P4q.s:159    .text:00000016 boot_program_page
     /tmp/cc2L9P4q.s:283    .vectors:00000000 boot
     /tmp/cc2L9P4q.s:311    .init2:00000000 init
     /tmp/cc2L9P4q.s:361    .init9:00000000 main
                             .bss:00000000 flashpage
     /tmp/cc2L9P4q.s:753    .bss:00000002 page_buffer_pos
     /tmp/cc2L9P4q.s:755    .bss:00000103 next_message_data_counter.1870
     /tmp/cc2L9P4q.s:754    .bss:00000003 page_buffer

UNDEFINED SYMBOLS
mcp2515_get_message
message_number
mcp2515_send_message
message_data
message_data_length
message_data_counter
__do_clear_bss
